## 图片过滤工具类
**背景：-**
**用途：过滤logo、国旗、异常图片、小图、渐变色图片等非实物图片**
```java
package com.cxy.utils;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.*;
import java.util.List;

public class ImageValidatorUtil {

    // 黑色白色颜色判断方差阈值-过滤颜色时越小越接近纯白或纯黑
    private static final int BLACK_WHITE_THRESHOLD = 15;
    // 接近透明像素阈值
    private static final int CLOSE_TO_THE_TRANSPARENCY_THRESHOLD = 1000 * 1000 / 100;
    // 最小颜色判断阈值下限
    private static final int MINIMUM_COLOR_LOWER_LIMIT = 10;
    // 噪点判断比例阈值
    private static final double NOISE_THRESHOLD = 0.001;
    // 不规则边缘占比阈值
    private static final double IRREGULAR_EDGE_PROPORTION_THRESHOLD = 0.80;
    // 总未忽略颜色所占比例阈值
    private static final double HAS_COLOR_RATIO_THRESHOLD =  0.75;
    // 复杂边缘判断阈值
    private static final double COMPLEX_EDGES_THRESHOLD =  0.005;
    // 主色调比例阈值
    private static final double TOP_3_COLOR_SOILED_THRESHOLD =  0.65;
    // 渐变色检测分块非空像素块像素占比阈值
    private static final double GRADIENT_DETECTION_BLOCK_TRANSPARENT_JUDGMENT_THRESHOLD =  0.95;

    private static BufferedImage preprocessImage(BufferedImage original) {
        int newWidth = 1000;
        int newHeight = 1000;
        BufferedImage resized = new BufferedImage(newWidth, newHeight, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = resized.createGraphics();
        g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
        g2d.drawImage(original, 0, 0, newWidth, newHeight, null);
        g2d.dispose();
        return resized;
    }

    private static boolean isLowResolution(BufferedImage image) {
        int width = image.getWidth();
        int height = image.getHeight();
        int totalPixels = width * height;
        return totalPixels < 8000;
    }

    public static boolean isTooSimpleOrStructuredImage(BufferedImage image) {
        if (image == null) return true;
        boolean lowResolution = isLowResolution(image); // 低分辨率过滤
        if (lowResolution) {
            return true;
        }
        image = preprocessImage(image);

        int width = image.getWidth();
        int height = image.getHeight();
        int totalPixels = width * height;
        // 1. 颜色分布分析（仅分析不透明区域）
        Map<String, Integer> colorRGBCountMap = new HashMap<>();
        Map<String, Integer> colorRGBCountMapFilter = new HashMap<>();
        int edgeCount = 0;
        int irregularEdgeCount = 0;

        // ARGB缓存
        int[][] argbCache = new int[width+1][height+1];

        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                int argb = image.getRGB(x, y);
                argbCache[x][y] = argb;
                String rgbString = getRgb(argb);
                if (rgbString == null) continue;
                colorRGBCountMap.merge(rgbString, 1, Integer::sum);
                // 边缘检测（跳过与透明像素的比较）
                if (x >= 1) {
                    int argbLeft = argbCache[x - 1][y];
                    String rgbLeftString = getRgb(argbLeft);
                    if (rgbLeftString == null) {
                        irregularEdgeCount++;
                        continue;
                    }
                    if (colorDiff(rgbString, rgbLeftString) > 30) {
                        edgeCount++;
                    }
                }
                if (y >= 1) {
                    int argbTop = argbCache[x][y - 1];
                    String rgbTopString = getRgb(argbTop);
                    if (rgbTopString == null) {
                        irregularEdgeCount++;
                        continue;
                    }
                    if (colorDiff(rgbString, rgbTopString) > 30) {
                        edgeCount++;
                    }
                }
            }
        }
        // 提前释放图片资源
        image = null;

        // 2. 透明区域分析
        int transparentPixelCount = analyzeTransparentAreas(argbCache, width, height);
        int opaquePixelCount = totalPixels - transparentPixelCount;

        // 如果图片完全透明, 或小于1%
        if (opaquePixelCount < CLOSE_TO_THE_TRANSPARENCY_THRESHOLD) return true;

        // 忽略噪点(颜色统计不足总色0.001的认为是噪点)
        long colorCountSum = 0;
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());
        for (Map.Entry<String, Integer> entry : colorRGBCountMap.entrySet()) {
            if (entry.getValue() > (opaquePixelCount * NOISE_THRESHOLD)) {
                // 删除噪点
                colorRGBCountMapFilter.put(entry.getKey(), entry.getValue());
                colorCountSum += entry.getValue();
                maxHeap.add(entry.getValue());
            }
        }

        boolean hasNoise = colorRGBCountMapFilter.size() != colorRGBCountMap.size();
        colorRGBCountMap = null; // 释放内存

        // 不规则边缘占比
        double irregularEdgeRatio = (double) irregularEdgeCount / (edgeCount + irregularEdgeCount);
        boolean hasIrregularEdges = irregularEdgeRatio > IRREGULAR_EDGE_PROPORTION_THRESHOLD;

        // 特征计算（基于不透明区域）
        int topSum = 0;
        int topOne = maxHeap.peek() != null ? maxHeap.peek() : 0;
        boolean isNonTransparent = ((double) opaquePixelCount / totalPixels) > 0.95;
        boolean isTopOneOnly = ((double) topOne / (double) opaquePixelCount) > 0.5;
        int opaquePixelCountExclude = opaquePixelCount;
        long colorCountSumExclude = colorCountSum;
        // 整张图都有像素点的图片，要忽略一下主色占比高于70%的颜色
        String excludeColor = null;
        if (isNonTransparent && isTopOneOnly) {
            Integer poll = maxHeap.poll();
            opaquePixelCountExclude -= poll != null ? poll : 0; // 弹出主色top1
            colorCountSumExclude -= poll != null ? poll : 0; // 弹出主色top1
            for(Map.Entry<String, Integer> item : colorRGBCountMapFilter.entrySet()) {
                if (Objects.equals(item.getValue(), poll)) {
                    excludeColor = item.getKey();
                }
            }
        }
        // 颜色种类
        boolean isLowNoise = ((double) colorCountSumExclude / (double) opaquePixelCountExclude) > HAS_COLOR_RATIO_THRESHOLD;
        boolean lowColorVariety = isLowNoise && colorRGBCountMapFilter.size() <= MINIMUM_COLOR_LOWER_LIMIT;
        if (! lowColorVariety) {
            // Top3颜色加起来占比在95%以上认为是纯色
            int count = 0;
            while (! maxHeap.isEmpty() && count < 3) {
                topSum += maxHeap.poll();
                count++;
            }
            lowColorVariety = isLowNoise && (topSum > colorCountSumExclude * TOP_3_COLOR_SOILED_THRESHOLD);
        }

        // 边缘复杂度
        boolean lowEdgeComplexity = edgeCount < (opaquePixelCount * COMPLEX_EDGES_THRESHOLD);

        // 如果有显著不规则边缘，则放宽其他条件（可能是合法的不规则图形）
        if (hasIrregularEdges) {
            // 仅当同时具有简单结构和低颜色变化时才视为非法
            return lowColorVariety && lowEdgeComplexity;
        } else if (hasNoise && isLowNoise && lowColorVariety) {
            return true;
        }

        // 面积连续的大纯色或渐变色遮盖
        return detectLargeSmoothCover(argbCache, width, height, 8, 15, 0.985, excludeColor);
    }


    private static String getRgb(int argb) {
        try {
            if ((argb >>> 24) == 0x00) return null;
            int r = (argb >> 16) & 0xFF;
            int g = (argb >> 8) & 0xFF;
            int b = argb & 0xFF;
            // 近似白：RGB 都大于等于 255 - BLACK_WHITE_THRESHOLD
            if (r >= 255 - BLACK_WHITE_THRESHOLD && g >= 255 - BLACK_WHITE_THRESHOLD && b >= 255 - BLACK_WHITE_THRESHOLD) {
                return null;
            }
            // 近似黑：RGB 都小于等于 BLACK_WHITE_THRESHOLD
            if (r <= BLACK_WHITE_THRESHOLD && g <= BLACK_WHITE_THRESHOLD && b <= BLACK_WHITE_THRESHOLD) {
                return null;
            }
            return r + "-" + g + "-" + b;
        } catch (Exception e) {
            return null;
        }
    }

    // 透明区域分析
    private static int analyzeTransparentAreas(int[][] argbCache, int width, int height) {
        int transparentCount = 0;
        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {
                int argb = argbCache[x][y];
                String rgbString = getRgb(argb);
                if (rgbString == null) {
                    transparentCount++;
                }
            }
        }
        return transparentCount;
    }

    private static double colorStdDev(List<String> colors) {
        double meanR = 0, meanG = 0, meanB = 0;
        for (String color : colors) {
            String[] strSpilt = color.split("-");
            meanR += Double.parseDouble(strSpilt[0]);
            meanG += Double.parseDouble(strSpilt[1]);
            meanB += Double.parseDouble(strSpilt[2]);
        }
        int n = colors.size();
        meanR /= n;
        meanG /= n;
        meanB /= n;

        double variance = 0;
        for (String color : colors) {
            String[] strSpilt = color.split("-");
            double dr = Double.parseDouble(strSpilt[0]) - meanR;
            double dg = Double.parseDouble(strSpilt[1]) - meanG;
            double db = Double.parseDouble(strSpilt[2]) - meanB;
            variance += dr * dr + dg * dg + db * db;
        }
        return Math.sqrt(variance / n);
    }

    private static int colorDiff(String rgb1, String rgb2) {
        String[] rgbString1 = rgb1.split("-");
        String[] rgbString2 = rgb2.split("-");
        int dr = Integer.parseInt(rgbString1[0]) - Integer.parseInt(rgbString2[0]);
        int dg = Integer.parseInt(rgbString1[1]) - Integer.parseInt(rgbString2[1]);
        int db = Integer.parseInt(rgbString1[2]) - Integer.parseInt(rgbString2[2]);
        return (int) Math.sqrt(dr * dr + dg * dg + db * db);
    }

    public static boolean detectLargeSmoothCover(int[][] argbCache, int width, int height, int blockSize, double colorStdDevThreshold, double areaThresholdRatio, String excludeColor) {
        int blocksX = (int) Math.ceil(width * 1.0 / blockSize);
        int blocksY = (int) Math.ceil(height * 1.0 / blockSize);

        // 判断每个块是否为“平滑块”
        boolean[][] isSmoothBlock = new boolean[blocksY][blocksX];
        boolean[][] visited = new boolean[blocksY][blocksX];
        int opacityPixelsSize = 0;
        for (int by = 0; by < blocksY; by++) {
            for (int bx = 0; bx < blocksX; bx++) {
                List<String> colors = new ArrayList<>();
                for (int dy = 0; dy < blockSize; dy++) {
                    for (int dx = 0; dx < blockSize; dx++) {
                        int x = bx * blockSize + dx;
                        int y = by * blockSize + dy;
                        if (x >= width || y >= height) continue;
                        int argb = argbCache[x][y];
                        if ((argb >>> 24) == 0x00) continue; // 忽略透明色
                        int r = (argb >> 16) & 0xFF;
                        int g = (argb >> 8) & 0xFF;
                        int b = argb & 0xFF;
                        String rgbStr = r + "-" + g + "-" + b;
                        if (rgbStr.equals(excludeColor)) {
                            continue;
                        }
                        colors.add(rgbStr);
                    }
                }
                if (colors.size() >= (blockSize * blockSize * GRADIENT_DETECTION_BLOCK_TRANSPARENT_JUDGMENT_THRESHOLD)) {
                    opacityPixelsSize ++;
                    isSmoothBlock[by][bx] = colorStdDev(colors) < colorStdDevThreshold;
                }
            }
        }

        // DFS 连通区域搜索
        int maxArea = 0;
        for (int y = 0; y < blocksY; y++) {
            for (int x = 0; x < blocksX; x++) {
                if (!isSmoothBlock[y][x] || visited[y][x]) continue;
                int area = floodFill(isSmoothBlock, visited, x, y);
                maxArea = Math.max(maxArea, area);
            }
        }

        double ratio = (double) maxArea / opacityPixelsSize;
        return ratio > areaThresholdRatio;
    }


    // Flood fill 寻找连通区域大小
    private static int floodFill(boolean[][] grid, boolean[][] visited, int startX, int startY) {
        int height = grid.length;
        int width = grid[0].length;
        int count = 0;
        Deque<int[]> stack = new ArrayDeque<>();
        stack.push(new int[]{startX, startY});
        visited[startY][startX] = true;

        int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

        while (!stack.isEmpty()) {
            int[] cur = stack.pop();
            count++;

            for (int[] dir : dirs) {
                int nx = cur[0] + dir[0];
                int ny = cur[1] + dir[1];
                if (nx >= 0 && ny >= 0 && nx < width && ny < height) {
                    if (!visited[ny][nx] && grid[ny][nx]) {
                        visited[ny][nx] = true;
                        stack.push(new int[]{nx, ny});
                    }
                }
            }
        }
        return count;
    }
}


```
