[toc]

# 代理模式

## 定义

> 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。

## 优缺点

代理模式的主要优点有：

- 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；
- 代理对象可以扩展目标对象的功能；
- 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性


其主要缺点是：

- 代理模式会造成系统设计中类的数量增加
- 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；
- 增加了系统的复杂度；

可以使用动态代理解决缺点

## spring的动态代理 AOP

## Proxy

动态生成代理类

```java
package com.cxy.util;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
public class ProxyInvocationHandler implements InvocationHandler {
    private Object target;
    //设置代理对象
    public void setTarget(Object target){
        this.target = target;
    }
    //获得代理类
    public Object getProxy(){
        return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this);
    }
    //处理代理实例
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        log(method.getName());
        return  method.invoke(target, args);
    }
    //提示日志
    public void log(String msg){
        System.out.println("代理处理了"+msg+"方法");
    }
}
```

测试

```java
package com.cxy.service;
import com.cxy.util.ProxyInvocationHandler;
public class Client {
    public static void main(String[] args) {
        //真实角色
        User user = new User();
        //代理角色
        ProxyInvocationHandler pih = new ProxyInvocationHandler();
        pih.setTarget(user);
        //动态生成代理类
        UserService proxy = (UserService) pih.getProxy();
        proxy.getUserService("送货");
    }
}
```

## Spring AOP

允许用户自定义切面

- 导入依赖包

```xml
<!--代理依赖-->
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.9.4</version>
</dependency>
```

### 接口api实现:

> 日志类
>
> ```java
> 1.
> package com.cxy.log;
> import org.springframework.aop.MethodBeforeAdvice;
> import java.lang.reflect.Method;
> public class Log implements MethodBeforeAdvice {
>  public void before(Method method, Object[] objects, Object o) throws Throwable {
>      System.out.println(o.getClass().getName()+"的"+method.getName()+"被执行了!");
>  }
> }
> 2.
> package com.cxy.log;
> import org.springframework.aop.AfterReturningAdvice;
> import java.lang.reflect.Method;
> public class AfterLog implements AfterReturningAdvice {
>  public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
>      System.out.println("执行了"+method.getName()+"方法,返回值:"+returnValue);
>  }
> }
> ```
>
> 2.实现类,真实对象
>
> ```java
> package com.cxy.service;
> public interface UserService {
>  String getUserService(String msg);
>  void add();
>  void delete();
> }
> 
> 2.
> package com.cxy.service;
> import org.springframework.stereotype.Component;
> public class User implements UserService{
>  public String getUserService(String msg) {
>      return msg;
>  }
>  public void add() {
>      System.out.println("添加了一个用户");
>  }
>  public void delete() {
>      System.out.println("删除了一个用户");
>  }
> }
> ```
>
> 
>
> spring配置
>
> ```xml
> <?xml version="1.0" encoding="UTF-8"?>
> <beans xmlns="http://www.springframework.org/schema/beans"
>     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
>     xmlns:aop="http://www.springframework.org/schema/aop"
>     xsi:schemaLocation="http://www.springframework.org/schema/beans
>      https://www.springframework.org/schema/beans/spring-beans.xsd
>      http://www.springframework.org/schema/aop
>      https://www.springframework.org/schema/aop/spring-aop.xsd
>     ">
>  <bean id="user" class="com.cxy.service.User"/>
>  <bean id="log" class="com.cxy.log.Log"/>
>  <bean id="afterLog" class="com.cxy.log.AfterLog"/>
> 
>  <aop:config>
>      <aop:pointcut id="pointcut" expression="execution(* com.cxy.service.User.*(..))"/>
>      <aop:advisor advice-ref="log" pointcut-ref="pointcut" />
>      <aop:advisor advice-ref="afterLog" pointcut-ref="pointcut"/>
>  </aop:config>
> 
> </beans>
> ```
>
> 测试类
>
> ```java
> @Test
>  public void text1(){
>      ApplicationContext context = new ClassPathXmlApplicationContext("bean.xml");
>      UserService user = (UserService)context.getBean("user");
>      user.add();
>  }
> ```
>
> 结果
>
> ```text
> com.cxy.service.User的add被执行了!
> 添加了一个用户
> 执行了add方法,返回值:null
> ```

### 自定义切面

> 1.自定义方法切面
>
> ```java
> package com.cxy.log;
> 
> public class MyDiyLog {
> 
>  public void befor(){
>      System.out.println("=====执行前========");
>  }
> 
>  public void after(){
>      System.out.println("=====执行后========");
>  }
> }
> ```
>
> 2.配置
>
> ```xml
> <?xml version="1.0" encoding="UTF-8"?>
> <beans xmlns="http://www.springframework.org/schema/beans"
>     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
>     xmlns:aop="http://www.springframework.org/schema/aop"
>     xsi:schemaLocation="http://www.springframework.org/schema/beans
>      https://www.springframework.org/schema/beans/spring-beans.xsd
>      http://www.springframework.org/schema/aop
>      https://www.springframework.org/schema/aop/spring-aop.xsd
>     ">
> 
>  <bean id="user" class="com.cxy.service.User"/>
>  <bean id="log" class="com.cxy.log.Log"/>
>  <bean id="afterLog" class="com.cxy.log.AfterLog"/>
>  <bean id="diy" class="com.cxy.log.MyDiyLog"/>
>  <aop:config>
>      <aop:aspect ref="diy">
>          <aop:pointcut id="point" expression="execution(* com.cxy.service.*.*(..))"/>
>          <aop:before method="befor" pointcut-ref="point"/>
>          <aop:after method="after" pointcut-ref="point"/>
>      </aop:aspect>
> 
>  </aop:config>
> 
> </beans>
> ```
>
> 3.测试
>
> ```java
> public class Text {
>  @Test
>  public void text1(){
>      ApplicationContext context = new ClassPathXmlApplicationContext("bean.xml");
>      UserService user = (UserService)context.getBean("user");
>      user.add();
>  }
> }
> ```
>
> 4.结果
>
> ```text
> =====执行前========
> 添加了一个用户
> =====执行后========
> 
> 进程已结束,退出代码0
> 
> ```

### 使用注解

@Aspect 标注这个类是一个切面

@Before 标注之前执行

@After 之后

@Around 给定一个参数,代理获取的切入点

- 实现类

  ```java
  package com.cxy.log;
  import org.aspectj.lang.annotation.After;
  import org.aspectj.lang.annotation.Aspect;
  import org.aspectj.lang.annotation.Before;
  public class AutoDiyli {
      @Before("execution(* com.cxy.service.*.*(..))")
      public void befor(){
          System.out.println("------------执行前----------");
      }
      @After("execution(* com.cxy.service.*.*(..))")
      public void after(){
          System.out.println("------------执行后----------");
      }
          @Around("execution(* com.cxy.service.*.*(..))")
      public void huan(ProceedingJoinPoint pjp) throws Throwable {
          System.out.println("=====环绕前====");
          Object proceed = pjp.proceed();
          pjp.getSignature();//获得签名
          System.out.println("=====环绕后====");
      }
  }
  ```

  - 配置

    ```xml
    <bean id="autolog" class="com.cxy.log.AutoDiyli"/>    
    <aop:aspectj-autoproxy/>
    ```

  - 结果

    ```java
    =====环绕前====
    ------------执行前----------
    添加了一个用户
    ------------执行后----------
    =====环绕后====
    ```

  - @Around



# 适配器模式

## 定义

> 适配器就像是转换器一样 , 使得原本不能在一起工作的两个接口可以在一起工作

- 适配器模式 分为
  - 类结构型模式
  - 对象结构型模式

> 类机构型模式的耦合度较高 , 所以应用的相对较少

## 适配器模式的特点

优点:

- 客户端可以通过适配器调用接口
- 复用了现有的类 , 不用修改原来的代码
- 将目标类和适配器解耦 , 解决了接口不一致的问题
- 符合开闭原则

缺点:

- 会增加系统的复杂度
- 增加代码的阅读难度 , 降低可读性 , 系统代码可以因此凌乱



## java实现

```java
/*****************************适配的接口*****************************/
public interface inteface1 {
    void me1();
}
/*****************************适配者*****************************/
public class Adaptee {
    public void okMe1(){
        System.out.println("适配器调用了一次方法");
    }
}
/*****************************适配器*****************************/
public class ClassAdapter extends Adaptee implements inteface1 {
    @Override
    public void me1() {
        //调用适配者的方法
        okMe1();
    }
}
/*****************************测试*****************************/
public class Client {
    public static void main(String[] args) {
        inteface1 inteface1 = new ClassAdapter();
        inteface1.me1();
    }
}
```

测试:

![image-20210602102556411](..\结构型模式\image-20210602102556411.png)

